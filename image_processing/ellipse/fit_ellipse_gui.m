function [] = fit_ellipse_gui(raw_volumes, varargin)
%FIT_ELLIPSE_GUI *Insert a one line summary here*
%   [] = fit_ellipse_gui(varargin)
%
% FIT_ELLIPSE_GUI uses the U_PACKARGS interface function
% and so arguments to the function may be passed as name-value pairs
% or as a struct with fields with corresponding names. The field names
% are defined as:
%
% Mandatory Arguments:
%
% Optional Arguments:
%
% Outputs:
%
% Example:
%
% Notes:
%
% See also:
%
% Created: 10-Aug-2017
% Author: Michael Berks 
% Email : michael.berks@manchester.ac.uk 
% Phone : +44 (0)161 275 7669 
% Copyright: (C) University of Manchester 

% Unpack the arguments:
% Unpack the arguments:
args = u_packargs(varargin, 0, ...
    'mask', [],...
    'voxel_dims', [2.9297 2.9297 4],...
    'radii_steps', [0.1 0.1],...
    'center_steps', [0.1 0.1],...
    'rotation_steps', pi/100,...
    'feature_fun', 'gradient',...
    'grad_sigma', 1,...
    'x_roi', [],...
    'y_roi', [],...
    'z_roi', [],...
    'x', [],...
    'y', [],...
    'z', [],...
    'im_types', {'*.hdr', '*.*'},...
    'root_dir', 'Q:/data/MB/travastin/');
%clear varargin;

switch(args.feature_fun)
    case 'gradient', feature_fun = @(x)grad(x, args.grad_sigma);
    case 'none', feature_fun = @none;
    otherwise,     error([args.feature_fun 'is not a recognised ''feature_fun'' parameter.'])
end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Program code that runs
%
%--------------------------------------------------------------------------
%Must have window style set to normal
orig_window_style = get(0,'DefaultFigureWindowStyle');
if ~strcmp(orig_window_style, 'normal')
    display('Warning: changing window style to normal for function');
    set(0,'DefaultFigureWindowStyle','normal');
end

%Set constants/variables that persist for all user sessions:
color1 = [1 1 1];
color2 = [212 208 200]/255; %#ok
color3 = [0 0 0];
buff = 5;
screen_size = get(0,'ScreenSize');

%Create empty variables that exist globally and will be filled auxilliary
%functions - this set do not need to be reset for each session

ui = [];
axes_pos1 = [];
axes_pos2 = [];
axes_pos3 = [];

panel_pos = [];

num_vols = [];
num_slices = [];
num_rows = [];
num_cols = [];

curr_vol = 1;
curr_slice = 1;
curr_row = 1;
curr_col = 1;

e2_axes = [];
e2_center = [];
e2_radii = [];
e2_params = [];
e2_plane = [];
e2_weighted_plane = [];
e2_weight = 0;
surface_points = [];

match_score = [];
old_match_score = [];
max_score = [];

feature_volume = [];

%main program
create_main_fig();

load_volumes();

%Reset window style
set(0,'DefaultFigureWindowStyle',orig_window_style);

%End of function

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Auxilliary functions so set up main UI figure (axes, buttons etc)
%
%--------------------------------------------------------------------------
    function create_main_fig
        %Generate main figure if it doens't already exist

        x_max = screen_size(3);
        y_max = screen_size(4)-80;
        x_width = x_max-4*buff;
        
        ui.main_fig = figure(...
            'Position', [0 20 x_max, y_max],...
            'Visible','on',...
            'Name', 'Fit ellipse tool',...
            'NumberTitle', 'off',...
            'MenuBar', 'none',...
            'WindowStyle', 'normal',...
            'Color', color1,...
            'WindowScrollWheelFcn', @scroll_Callback,...
            'KeyPressFcn',  @keypress_Callback,...
            'CloseRequestFcn', @quit_Callback);         
        
        
        figure(ui.main_fig);
        set(ui.main_fig,...
            'Color', color3,...
            'CloseRequestFcn', @quit_Callback); 
        
        axes_pos1 = [buff buff  x_width/2       y_max - 2*buff];
        axes_pos2 = [2*buff+axes_pos1(3) buff x_width/3 (y_max - 3*buff)/2];
        axes_pos3 = axes_pos2;
        axes_pos3(2) = axes_pos3(2) + buff + axes_pos2(4);
        
        panel_pos = [x_max - buff - x_width/6 buff x_width/6 y_max - 2*buff];
        
        button_h = 60;
        button_w = 60;
        text_w = 200;
        text_h = 25;
        panel_h = 200;
        panel_w = panel_pos(3) - 2*buff;
        
        ui.menu = uimenu(ui.main_fig,'Label','File');
        ui.menu_item1 = uimenu(ui.menu,...
            'Label', 'Load new sequence',...
            'Callback', @load_new_sequence);
        ui.menu_item2 = uimenu(ui.menu,...
            'Label','Load mask',...
            'Callback', @load_mask);
        ui.menu_item3 = uimenu(ui.menu,...
            'Label','Quit',...
            'Callback', @quit_Callback);
        
        ui.panel = uicontrol(...
            'Style','frame',...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', panel_pos,...
            'Visible', 'on');
        
        %------------------------------------------------------------------
        ui.panel_center = uipanel(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', [panel_pos(1)+buff panel_pos(4)-(buff+panel_h) panel_w-2*buff panel_h],...
            'Visible', 'on');
           
        ui.center_x_text = uicontrol(... 
            'Parent', ui.panel_center,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'X center:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(text_h+buff) text_w text_h]); 
        
        ui.center_x_inc = uicontrol(... 
            'Position', [2*buff+button_w panel_h-(buff+2*text_h) button_w text_h],...
            'String', '+',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_center,...
            'Enable', 'off',...
            'Callback', @center_x_inc);
        
        ui.center_x_dec = uicontrol(... 
            'Position', [buff panel_h-(buff+2*text_h) button_w text_h],...
            'String', '-',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_center,...
            'Enable', 'off',...
            'Callback', @center_x_dec);
        
        ui.center_y_text = uicontrol(... 
            'Parent', ui.panel_center,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Y center:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(3*buff+3*text_h) text_w+button_w+buff text_h]); 
        
        ui.center_y_inc = uicontrol(... 
            'Position', [2*buff+button_w panel_h-(3*buff+4*text_h) button_w text_h],...
            'String', '+',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_center,...
            'Enable', 'off',...
            'Callback', @center_y_inc);
        
        ui.center_y_dec = uicontrol(... 
            'Position', [buff panel_h-(3*buff+4*text_h) button_w text_h],...
            'String', '-',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_center,...
            'Enable', 'off',...
            'Callback', @center_y_dec);

        %---------------------------------------------------------------
        %------------------------------------------------------------------
        ui.panel_radii = uipanel(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', [panel_pos(1)+buff panel_pos(4)-(2*buff+2*panel_h) panel_w-2*buff panel_h],...
            'Visible', 'on');
           
        ui.radii_x_text = uicontrol(... 
            'Parent', ui.panel_radii,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'X radii:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(text_h+buff) text_w text_h]); 
        
        ui.radii_x_inc = uicontrol(... 
            'Position', [2*buff+button_w panel_h-(buff+2*text_h) button_w text_h],...
            'String', '+',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_radii,...
            'Enable', 'off',...
            'Callback', @radii_x_inc);
        
        ui.radii_x_dec = uicontrol(... 
            'Position', [buff panel_h-(buff+2*text_h) button_w text_h],...
            'String', '-',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_radii,...
            'Enable', 'off',...
            'Callback', @radii_x_dec);
        
        ui.radii_y_text = uicontrol(... 
            'Parent', ui.panel_radii,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Y radii:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(3*buff+3*text_h) text_w+button_w+buff text_h]); 
        
        ui.radii_y_inc = uicontrol(... 
            'Position', [2*buff+button_w panel_h-(3*buff+4*text_h) button_w text_h],...
            'String', '+',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_radii,...
            'Enable', 'off',...
            'Callback', @radii_y_inc);
        
        ui.radii_y_dec = uicontrol(... 
            'Position', [buff panel_h-(3*buff+4*text_h) button_w text_h],...
            'String', '-',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_radii,...
            'Enable', 'off',...
            'Callback', @radii_y_dec);
        
        %---------------------------------------------------------------
        %------------------------------------------------------------------
        ui.panel_axes = uipanel(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', [panel_pos(1)+buff panel_pos(4)-(3*buff+3*panel_h) panel_w-2*buff panel_h],...
            'Visible', 'on');
           
        ui.rot_text = uicontrol(... 
            'Parent', ui.panel_axes,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Rotate:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(text_h+buff) text_w text_h]); 
        
        ui.rot_inc = uicontrol(... 
            'Position', [2*buff+button_w panel_h-(buff+2*text_h) button_w text_h],...
            'String', '+',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_axes,...
            'Enable', 'off',...
            'Callback', @rot_inc);
        
        ui.rot_dec = uicontrol(... 
            'Position', [buff panel_h-(buff+2*text_h) button_w text_h],...
            'String', '-',...
            'Style', 'pushbutton',...
            'Parent', ui.panel_axes,...
            'Enable', 'off',...
            'Callback', @rot_dec);
        
        %---------------------------------------------------------------
        ui.panel_slice = uipanel(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', [panel_pos(1)+buff panel_pos(4)-(4*buff+4*panel_h) panel_w-2*buff panel_h],...
            'Visible', 'on');
        
        ui.slice_slider_text = uicontrol(... 
            'Parent', ui.panel_slice,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Select slice:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-buff text_w text_h]); 
        
        ui.slice_slider = uicontrol(... 
            'Style', 'slider',...
            'Position', [buff panel_h - (buff+text_h) text_w+button_w+buff text_h],...
            'String', 'Select',...
            'Min', 0,...
            'Max', 1,...
            'Value', 0,...
            'SliderStep', [1/3 1/3],...
            'Parent', ui.panel_slice,...
            'Enable', 'off',...
            'Callback', @slice_slider);
        
        ui.row_slider_text = uicontrol(... 
            'Parent', ui.panel_slice,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Select row:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h - (3*buff+2*text_h) text_w text_h]); 
        
        ui.row_slider = uicontrol(... 
            'Style', 'slider',...
            'Position', [buff panel_h - (3*buff+3*text_h) text_w+button_w+buff text_h],...
            'String', 'Select',...
            'Min', 0,...
            'Max', 1,...
            'Value', 0,...
            'SliderStep', [1/3 1/3],...
            'Parent', ui.panel_slice,...
            'Enable', 'off',...
            'Callback', @row_slider);
        
        ui.col_slider_text = uicontrol(... 
            'Parent', ui.panel_slice,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Select row:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h - (5*buff+4*text_h) text_w text_h]); 
        
        ui.col_slider = uicontrol(... 
            'Style', 'slider',...
            'Position', [buff panel_h - (5*buff+5*text_h) text_w+button_w+buff text_h],...
            'String', 'Select',...
            'Min', 0,...
            'Max', 1,...
            'Value', 0,...
            'SliderStep', [1/3 1/3],...
            'Parent', ui.panel_slice,...
            'Enable', 'off',...
            'Callback', @col_slider);
        
        ui.vol_slider_text = uicontrol(... 
            'Parent', ui.panel_slice,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Select volume:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h - (7*buff+6*text_h) text_w text_h]); 
        
        ui.vol_slider = uicontrol(... 
            'Style', 'slider',...
            'Position', [buff panel_h - (7*buff+7*text_h) text_w+button_w+buff text_h],...
            'String', 'Select',...
            'Min', 0,...
            'Max', 1,...
            'Value', 0,...
            'SliderStep', [1/3 1/3],...
            'Parent', ui.panel_slice,...
            'Enable', 'off',...
            'Callback', @vol_slider);
        %---------------------------------------------------------------
        %------------------------------------------------------------------
        ui.panel_score = uipanel(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Position', [panel_pos(1)+buff panel_pos(4)-(6*buff+5*panel_h) panel_w-2*buff panel_h],...
            'Visible', 'on');
        
        index = find(strcmpi(args.feature_fun, {'Gradient';'None'}));
        ui.select_feature = uicontrol(...
            'Parent', ui.panel_score,... 
            'Style','Listbox',...
            'String',{'Gradient';'None'},...
            'Position',[buff panel_h-(button_h+buff) text_w button_h],...
            'Value', index,...
            'Callback', @select_feature);
        
        ui.score_text = uicontrol(... 
            'Parent', ui.panel_score,... 
            'Style','text',...
            'BackgroundColor', get(ui.panel, 'BackgroundColor'),...
            'FontName', 'Arial',...
            'String', 'Matching score:',...
            'HorizontalAlignment', 'left',...
            'Position', [buff panel_h-(text_h+button_h+2*buff) text_w text_h]);
        %---------------------------------------------------------------
        
        %------------------------------------------------------------------
        %------------------------------------------------------------------
        ui.axes1 = axes(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Visible', 'off');
        ui.region1 = imagesc([]);
        set(ui.axes1,...
            'Position', axes_pos1,...
            'Xtick', [],...
            'Ytick', [],...
            'YDir','reverse',...
            'NextPlot', 'add');
        
        ui.axes2 = axes(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Visible', 'off');
        ui.region2 = imagesc([]);
        set(ui.axes2,...
            'Position', axes_pos2,...
            'Xtick', [],...
            'Ytick', [],...
            'YDir','reverse',...
            'NextPlot', 'add');
        
        ui.axes3 = axes(...
            'Parent', ui.main_fig,...
            'Units', 'pixels',...
            'Visible', 'off');
        ui.region3 = imagesc([]);
        set(ui.axes3,...
            'Position', axes_pos3,...
            'Xtick', [],...
            'Ytick', [],...
            'YDir','reverse',...
            'NextPlot', 'add');
        
        
        set(ui.main_fig,...
            'Colormap', gray(256));%[jet(128); gray(128)]
         
        colours = lines(3);
        
        ui.ellipse(1) = plot(1, 1,...
            'Parent', ui.axes1,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(1,:),...
            'MarkerSize', 6,...
            'LineStyle', '-',...
            'LineWidth', 2,...
            'Color', colours(1,:));        
        ui.tumour1 = plot(1, 1,...
            'Parent', ui.axes1,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(1,:),...
            'MarkerSize', 6,...
            'LineStyle', 'none');  
        ui.axis1_x = plot(1, 1,...
            'Parent', ui.axes1,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(2,:));
        ui.axis1_y = plot(1, 1,...
            'Parent', ui.axes1,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(3,:));
        ui.rect1 = imrect(...
            ui.axes1, [1 1 axes_pos1(3) axes_pos1(4)]);
        setPositionConstraintFcn(ui.rect1,...
            makeConstrainToRectFcn('imrect', [1 axes_pos1(3)], [1 axes_pos1(4)]));
        ui.rect1_callback = ...
            addNewPositionCallback(ui.rect1, @(p) select_xy_roi(p));     
            

        ui.ellipse(2) = plot(1, 1,...
            'Parent', ui.axes2,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(2,:),...
            'MarkerSize', 6,...
            'LineStyle', '-',...
            'LineWidth', 2,...
            'Color', colours(2,:));
        ui.tumour2 = plot(1, 1,...
            'Parent', ui.axes2,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(2,:),...
            'MarkerSize', 6,...
            'LineStyle', 'none');
        ui.axis2_y = plot(1, 1,...
            'Parent', ui.axes2,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(3,:));
        ui.axis2_z = plot(1, 1,...
            'Parent', ui.axes2,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(1,:));
        ui.rect2 = imrect(...
            ui.axes2, [1 1 axes_pos2(3) axes_pos2(4)]);
        setPositionConstraintFcn(ui.rect2, ...
            makeConstrainToRectFcn('imrect', [1 axes_pos2(3)], [1 axes_pos2(4)]));
        ui.rect2_callback = ...
            addNewPositionCallback(ui.rect2, @(p) select_yz_roi(p));     

        ui.ellipse(3) = plot(1, 1,...
            'Parent', ui.axes3,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(3,:),...
            'MarkerSize', 6,...
            'LineStyle', '-',...
            'LineWidth', 2,...
            'Color', colours(3,:));
        ui.tumour3 = plot(1, 1,...
            'Parent', ui.axes3,...
            'Visible', 'off',...
            'Marker', '.',...
            'MarkerEdgeColor', colours(3,:),...
            'MarkerSize', 6,...
            'LineStyle', 'none');
        ui.axis3_x = plot(1, 1,...
            'Parent', ui.axes3,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(2,:));
        ui.axis3_z = plot(1, 1,...
            'Parent', ui.axes3,...
            'Visible', 'off',...
            'Marker', 'none',...
            'LineStyle', '-.',...
            'LineWidth', 0.5,...
            'Color', colours(1,:));
        ui.rect3 = imrect(...
            ui.axes3, [1 1 axes_pos3(3) axes_pos3(4)]);
        setPositionConstraintFcn(ui.rect3,...
            makeConstrainToRectFcn('imrect', [1 axes_pos3(3)], [1 axes_pos3(4)]));
        ui.rect3_callback = ...
            addNewPositionCallback(ui.rect3, @(p) select_xz_roi(p));

    end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Auxilliary functions that control data
%
%--------------------------------------------------------------------------

    function load_volumes()
        set(ui.main_fig, 'pointer', 'watch');
        if isempty(raw_volumes)
            return;
            
        elseif iscellstr(raw_volumes)
            volume_names = raw_volumes;
            num_vols = length(volume_names);
            [~,hdr] = load_img_volume(volume_names{1});
            num_rows = double(hdr.Dimensions(2));
            num_cols = double(hdr.Dimensions(1)); 
            num_slices = double(hdr.Dimensions(3));
            if isempty(args.x)
                args.voxel_dims = hdr.PixelDimensions;
            end
            
            raw_volumes = zeros(num_rows, num_cols, num_slices, num_vols);
            for i_vol = 1:num_vols
                raw_volumes(:,:,:,i_vol) = ...
                    load_img_volume(volume_names{i_vol});
            end
        else
            [num_rows num_cols num_slices num_vols] = size(raw_volumes);
        end
        
        
        if isempty(args.x_roi)
            args.x_roi = 1:num_cols;
            args.y_roi = 1:num_rows;
            args.z_roi = 1:num_slices;
        else
            num_cols = length(args.x_roi);
            num_rows = length(args.y_roi);
            num_slices = length(args.z_roi);
        end
        if isempty(args.x)
            [args.x args.y args.z] = ...
                meshgrid(...
                args.x_roi*args.voxel_dims(2),...
                args.y_roi*args.voxel_dims(1),...
                args.z_roi*args.voxel_dims(3));
        end
        curr_row = round(num_rows/2);
        curr_col = round(num_cols/2);
        curr_slice = round(num_slices/2);
        
        
        if ~isempty(args.mask) &&...
                size(args.mask,1)==num_rows && ...
                size(args.mask,2)==num_cols && ...
                size(args.mask,3)==num_slices
            %see if there's a mask to initialise the ellipse
            make_ellipse_from_mask(args.mask)
        else
            e2_axes = repmat(eye(2), 1, 1, num_slices);
            e2_center = repmat([mean(args.x(1,:,1)) mean(args.y(:,1,1))], num_slices, 1);
            e2_radii = repmat([std(args.x(1,:,1)) std(args.y(:,1,1))], num_slices, 1);
        end
        curr_vol = 1;
        load_volume();
        enable_controls();
        set(ui.main_fig, 'pointer', 'arrow');
    end

    function load_volume()
        fv = feval(feature_fun, raw_volumes(:,:,:,curr_vol));
        feature_volume = fv(args.y_roi, args.x_roi, args.z_roi);
        
        %Reset the ellipse volume and weight
        e2_weight = 0;
        match_score = 0;
        old_match_score = 0;
        max_score = 0;
        update_ellipse();
        set_slider_limits();
        
        %Set limits for view axes
        caxis(ui.axes1, [min(feature_volume(:)) max(feature_volume(:))]);
        
        %Update volume slider text
        set(ui.vol_slider_text, 'String',...
            ['Select volume:' num2str(curr_vol)]);
               
    end

    function make_ellipse_from_mask(mask)
        
        if ischar(mask)
            mask = load_img_volume(mask) > 0;
        end
        %Note although called make_tumour_surface this works as general
        %function to get surface points
        [~, surface_points] = ...
            make_tumour_surface(mask, [], args.voxel_dims);
        [~, ~, ~, e3_params] = ellipsoid_fit(surface_points);
        for i_slice = 1:num_slices
            [v2] = compute_ellipsoid_z_slice(e3_params, args.z(1,1,i_slice));
            [e2_center_i, e2_radii_i, e2_axes_i, e2_signs_i] = ellipse_params( v2 );
            if all(e2_signs_i(:) > 0)
                e2_center(i_slice,:) = e2_center_i(:)';
                e2_radii(i_slice,:) = e2_radii_i(:)';
                e2_axes(:,:,i_slice) = e2_axes_i;
            else
                e2_axes(:,:,i_slice) = eye(2);
                e2_center(i_slice,:) = [mean(args.x(1,:,1)) mean(args.y(:,1,1))]; 
                e2_radii(i_slice,:) = [args.voxel_dims(1) args.voxel_dims(2) 1];
            end
        end
    end

    function update_ellipse()
        e2_params = ellipse_general(e2_center, e2_radii, e2_axes);
        [e2_plane] = compute_ellipse_plane(e2_params, args.x, args.y);
        if ~e2_weight
            e2_weight = 1 / mean(e2_plane(e2_plane > 0));
        end
        e2_weighted_plane = exp(-weights*abs(e2_plane));
        old_match_score = match_score;
        match_score = sum(sum(feature_volume(:,:,curr_slice) .* e2_weighted_plane(:)));
        update_view();
    end

    function update_view()
        
        %------------------------------------------------------------------
        %Display the volume slice in the main axes
        im1 = imresize(feature_volume(:,:,curr_slice), [axes_pos1(4) axes_pos1(3)]);
        set(ui.axes1,...
                'Position', axes_pos1,...
                'Xlim', [0.5 axes_pos1(3)+0.5],...
                'Ylim', [0.5 axes_pos1(4)+0.5]);
        set(ui.region1,...
                'Visible', 'on',...
                'CData', im1,...
                'XData', [1 axes_pos1(3)],...
                'YData', [1 axes_pos1(4)]);
            
        %Display the current ellipse in the slice
        [ex2 ey2] = ellipse(...
            e2_radii(curr_slice,1), e2_radii(curr_slice,2),...
            e2_center(curr_slice,1), e2_center(curr_slice,2), ...
            e2_axes(:,1,curr_slice), 0, 50);
            
        exi2 = interp1(args.x(1,:,1), linspace(1, axes_pos1(3), num_cols), ex2);
        eyi2 = interp1(args.y(:,1,1), linspace(1, axes_pos1(4), num_rows), ey2);
        set(ui.ellipse(1),...
            'XData', exi2,...
            'YData', eyi2,...
            'visible', 'on');
        
        set(ui.axis1_x,...
            'XData', [curr_col curr_col]*axes_pos1(3)/num_cols,...
            'YData', [1 num_rows]*axes_pos1(4)/num_rows,...
            'visible', 'on');
        set(ui.axis1_y,...
            'XData', [1 num_cols]*axes_pos1(3)/num_cols,...
            'YData', [curr_row curr_row]*axes_pos1(4)/num_rows,...
            'visible', 'on');
        
        if ~isempty(surface_points) && any(surface_points(:,3)==args.z(1,1,curr_slice))
           tidx = surface_points(:,3)==args.z(1,1,curr_slice);
           txi = interp1(args.x(1,:,1), linspace(1, axes_pos1(3), num_cols), surface_points(tidx,1));
           tyi = interp1(args.y(:,1,1), linspace(1, axes_pos1(4), num_rows), surface_points(tidx,2));
           
           set(ui.tumour1,...
            'XData', txi,...
            'YData', tyi,...
            'visible', 'on');
        else
            set(ui.tumour1,...
                'visible', 'off');
        end
        
        %------------------------------------------------------------------
        %Display the volume slice in the main axes
        im2 = imresize(permute(feature_volume(:,curr_col,:), [3 1 2]),...
            [axes_pos2(4) axes_pos2(3)]);
        set(ui.axes2,...
                'Position', axes_pos2,...
                'Xlim', [0.5 axes_pos2(3)+0.5],...
                'Ylim', [0.5 axes_pos2(4)+0.5]);
        set(ui.region2,...
                'Visible', 'on',...
                'CData', im2,...
                'XData', [1 axes_pos2(3)],...
                'YData', [1 axes_pos2(4)]);
            
        %Display the current ellipse in the slice
        [v2] = compute_ellipsoid_x_slice(e2_params, args.x(1,curr_col,1));
        [e2_center, e2_radii, e2_axis, e2_signs] = ellipse_params( v2 );
        if all(e2_signs(:) > 0)
            [ey2 ez2] = ...
                ellipse(e2_radii(1), e2_radii(2), e2_center(1), e2_center(2), e2_axis(:,1), 0, 50);
            
            eyi2 = interp1(args.y(:,1,1), linspace(1, axes_pos2(3), num_rows), ey2);
            ezi2 = interp1(args.z(1,1,:), linspace(1, axes_pos2(4), num_slices), ez2);
            set(ui.ellipse(2),...
                'XData', eyi2,...
                'YData', ezi2,...
                'visible', 'on');
        else
            set(ui.ellipse(2),...
                'visible', 'off');
        end
        
        set(ui.axis2_y,...
            'XData', [curr_row curr_row]*axes_pos2(3)/num_rows,...
            'YData', [1 num_slices]*axes_pos2(4)/num_slices,...
            'visible', 'on');
        set(ui.axis2_z,...
            'XData', [1 num_rows]*axes_pos2(3)/num_rows,...
            'YData', [curr_slice curr_slice]*axes_pos2(4)/num_slices,...
            'visible', 'on');
        
        if ~isempty(surface_points) && any(surface_points(:,1)==args.x(1,curr_col,1))
           tidx = surface_points(:,1)==args.x(1,curr_col,1);
           tyi = interp1(args.y(:,1,1), linspace(1, axes_pos2(3), num_rows), surface_points(tidx,2));
           tzi = interp1(args.z(1,1,:), linspace(1, axes_pos2(4), num_slices), surface_points(tidx,3));
           
           set(ui.tumour2,...
            'XData', tyi,...
            'YData', tzi,...
            'visible', 'on');
        else
            set(ui.tumour2,...
                'visible', 'off');
        end
        
        %------------------------------------------------------------------
        %Display the volume slice in the main axes
        im3 = imresize(permute(feature_volume(curr_row,:,:), [3 2 1]),...
            [axes_pos3(4) axes_pos3(3)]);
        set(ui.axes3,...
                'Position', axes_pos3,...
                'Xlim', [0.5 axes_pos3(3)+0.5],...
                'Ylim', [0.5 axes_pos3(4)+0.5]);
        set(ui.region3,...
                'Visible', 'on',...
                'CData', im3,...
                'XData', [1 axes_pos3(3)],...
                'YData', [1 axes_pos3(4)]);
            
        %Display the current ellipse in the slice
        [v2] = compute_ellipsoid_y_slice(e2_params, args.y(curr_row,1,1));
        [e2_center, e2_radii, e2_axis, e2_signs] = ellipse_params( v2 );
        if all(e2_signs(:) > 0)
            [ex2 ez2] = ...
                ellipse(e2_radii(1), e2_radii(2), e2_center(1), e2_center(2), e2_axis(:,1), 0, 50);
            
            exi2 = interp1(args.x(1,:,1), linspace(1, axes_pos3(3), num_cols), ex2);
            ezi2 = interp1(args.z(1,1,:), linspace(1, axes_pos3(4), num_slices), ez2);
            set(ui.ellipse(3),...
                'XData', exi2,...
                'YData', ezi2,...
                'visible', 'on');
        else
            set(ui.ellipse(3),...
                'visible', 'off');
        end 
        
        set(ui.axis3_x,...
            'XData', [curr_col curr_col]*axes_pos3(3)/num_cols,...
            'YData', [1 num_slices]*axes_pos3(4)/num_slices,...
            'visible', 'on');
        set(ui.axis3_z,...
            'XData', [1 num_cols]*axes_pos3(3)/num_cols,...
            'YData', [curr_slice curr_slice]*axes_pos3(4)/num_slices,...
            'visible', 'on');
        
        if ~isempty(surface_points) && any(surface_points(:,2)==args.y(curr_row,1,1))
           tidx = surface_points(:,2)==args.y(curr_row,1,1);
           txi = interp1(args.x(1,:,1), linspace(1, axes_pos3(3), num_cols), surface_points(tidx,1));
           tzi = interp1(args.z(1,1,:), linspace(1, axes_pos3(4), num_slices), surface_points(tidx,3));
           
           set(ui.tumour3,...
            'XData', txi,...
            'YData', tzi,...
            'visible', 'on');
        else
            set(ui.tumour3,...
                'visible', 'off');
        end
        %------------------------------------------------------------------
        
        set(ui.score_text, 'String', ['Match score: ' num2str(match_score)]);
        if match_score > max_score
            max_score = match_score;
            set(ui.score_text, 'ForegroundColor', 'g');
        elseif match_score > old_match_score
            set(ui.score_text, 'ForegroundColor', 'c');
        else
            set(ui.score_text, 'ForegroundColor', 'r');
        end
        
        update_control_display()
    end

    function update_roi()
        rect_pos1 = getPosition(ui.rect1);
        x_start = round(interp1(linspace(1, axes_pos1(3), num_cols), args.x_roi, rect_pos1(1)));
        x_end = round(interp1(linspace(1, axes_pos1(3), num_cols), args.x_roi, rect_pos1(1)+rect_pos1(3)-1));
        y_start = round(interp1(linspace(1, axes_pos1(4), num_rows), args.y_roi, rect_pos1(2)));
        y_end = round(interp1(linspace(1, axes_pos1(4), num_rows), args.y_roi, rect_pos1(2)+rect_pos1(4)-1));
        
        rect_pos2 = getPosition(ui.rect2);
        z_start = round(interp1(linspace(1, axes_pos2(4), num_slices), args.z_roi, rect_pos2(2)));
        z_end = round(interp1(linspace(1, axes_pos2(4), num_slices), args.z_roi, rect_pos2(2)+rect_pos2(4)-1));
       
        args.x_roi = x_start:x_end;
        args.y_roi = y_start:y_end;
        args.z_roi = z_start:z_end;
        [args.x args.y args.z] = ...
            meshgrid(...
            args.x_roi*args.voxel_dims(2),...
            args.y_roi*args.voxel_dims(1),...
            args.z_roi*args.voxel_dims(3));
        
        num_cols = length(args.x_roi);
        num_rows = length(args.y_roi);
        num_slices = length(args.z_roi);
        
        if curr_row > num_rows
            curr_row = round(num_rows/2);
        end
        if curr_col > num_cols
            curr_col = round(num_cols/2);
        end
        if curr_slice > num_slices
            curr_slice = round(num_slices/2);
        end
        
        %reset rectangle positions in each axes
        setPosition(ui.rect1, [1 1 axes_pos1(3) axes_pos1(4)]);
        setPosition(ui.rect2, [1 1 axes_pos2(3) axes_pos2(4)]);
        setPosition(ui.rect3, [1 1 axes_pos3(3) axes_pos3(4)]);
        
        load_volume();
    end

    function reset_roi()      
        args.x_roi = 1:size(raw_volumes,1);
        args.y_roi = 1:size(raw_volumes,2);
        args.z_roi = 1:size(raw_volumes,3);
        [args.x args.y args.z] = ...
            meshgrid(...
            args.x_roi*args.voxel_dims(2),...
            args.y_roi*args.voxel_dims(1),...
            args.z_roi*args.voxel_dims(3));
        
        num_cols = length(args.x_roi);
        num_rows = length(args.y_roi);
        num_slices = length(args.z_roi);
        
        if curr_row > num_rows
            curr_row = round(num_rows/2);
        end
        if curr_col > num_cols
            curr_col = round(num_cols/2);
        end
        if curr_slice > num_slices
            curr_slice = round(num_slices/2);
        end
        
        %reset rectangle positions in each axes
        setPosition(ui.rect1, [1 1 axes_pos1(3) axes_pos1(4)]);
        setPosition(ui.rect2, [1 1 axes_pos2(3) axes_pos2(4)]);
        setPosition(ui.rect3, [1 1 axes_pos3(3) axes_pos3(4)]);
        
        load_volume();
    end

    function set_slider_limits()
        set(ui.slice_slider,...
            'Min', 1,...
            'Max', num_slices,...
            'SliderStep', [1/(num_slices-1) 1/(num_slices-1)],...
            'Value', curr_slice,...
            'Enable', 'on');
        
        set(ui.row_slider,...
            'Min', 1,...
            'Max', num_rows,...
            'SliderStep', [1/(num_rows-1) 1/(num_rows-1)],...
            'Value', curr_row,...
            'Enable', 'on');
        
        set(ui.col_slider,...
            'Min', 1,...
            'Max', num_cols,...
            'SliderStep', [1/(num_cols-1) 1/(num_cols-1)],...
            'Value', curr_col,...
            'Enable', 'on');
        
        set(ui.vol_slider,...
            'Min', 1,...
            'Max', num_vols,...
            'SliderStep', [1/(num_vols-1) 1/(num_vols-1)],...
            'Value', curr_vol,...
            'Enable', 'on');
        
    end

    function enable_controls()
        set(ui.center_x_inc, 'Enable', 'on');       
        set(ui.center_x_dec, 'Enable', 'on');       
        set(ui.center_y_inc, 'Enable', 'on');       
        set(ui.center_y_dec, 'Enable', 'on');       
        set(ui.center_z_inc, 'Enable', 'on');       
        set(ui.center_z_dec, 'Enable', 'on');       
        set(ui.radii_x_inc, 'Enable', 'on');       
        set(ui.radii_x_dec, 'Enable', 'on');       
        set(ui.radii_y_inc, 'Enable', 'on');       
        set(ui.radii_y_dec, 'Enable', 'on');       
        set(ui.radii_z_inc, 'Enable', 'on');       
        set(ui.radii_z_dec, 'Enable', 'on');       
        set(ui.rot_z_inc, 'Enable', 'on');       
        set(ui.rot_z_dec, 'Enable', 'on');       
        set(ui.rot_y_inc, 'Enable', 'on');       
        set(ui.rot_y_dec, 'Enable', 'on');
        set(ui.rot_x_inc, 'Enable', 'on');       
        set(ui.rot_x_dec, 'Enable', 'on');
    end

    function update_control_display()
        set(ui.center_x_text, 'String',...
            ['X center:' num2str(e2_center(1),4)]);
        set(ui.center_y_text, 'String',...
            ['Y center:' num2str(e2_center(2),4)]);
        set(ui.center_z_text, 'String',...
            ['Z center:' num2str(e2_center(3),4)]);
        set(ui.radii_x_text, 'String',...
            ['X radius:' num2str(e2_radii(1),4)]);
        set(ui.radii_y_text, 'String',...
            ['Y radius:' num2str(e2_radii(2),4)]);
        set(ui.radii_z_text, 'String',...
            ['Z radius:' num2str(e2_radii(3),4)]);
        set(ui.slice_slider_text, 'String',...
            ['Select slice:' num2str(curr_slice)]);
        set(ui.row_slider_text, 'String',...
            ['Select row:' num2str(curr_row)]);
        set(ui.col_slider_text, 'String',...
            ['Select col:' num2str(curr_col)]);
        
    end
    

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% UI Callbacks
%
%--------------------------------------------------------------------------
% --------------------------------------------------------------------

% --------------------------------------------------------------------
    function quit_Callback(hObject, eventdata) %#ok
    % Callback executed if the user tries to quit
        %Check if they're ok to quit
        delete(ui.main_fig);
    end

% --------------------------------------------------------------------
    function load_new_sequence(hObject, eventdata) %#ok
    % Callback...        
    	%Check if they're ok to quit
        [volume_names, path_name] = ...
            uigetfile(args.im_types, 'Select volumes', args.root_dir, ...
            'MultiSelect', 'on');
        if iscellstr(volume_names)
            raw_volumes = strcat(path_name, volume_names(:));
            args.x_roi = [];
            args.x = [];
            load_volumes();
        end

    end

% --------------------------------------------------------------------
    function load_mask(hObject, eventdata) %#ok
    % Callback...        
    	[mask_name, path_name] = ...
            uigetfile(args.im_types, 'Select volumes', args.root_dir, ...
            'MultiSelect', 'off');
        if ischar(mask_name)
            mask = load_img_volume(fullfile(path_name, mask_name)) > 0;
            
            if size(mask,1)==num_rows && ...
                size(mask,2)==num_cols && ...
                size(mask,3)==num_slices
                make_ellipse_from_mask(mask);
                update_ellipse();
            end
        end

    end


% --------------------------------------------------------------------
    function center_x_inc(hObject, eventdata) %#ok
    % Callback...        
    	e2_center(1) = e2_center(1) + args.center_steps(1);        
        update_ellipse();

    end

% --------------------------------------------------------------------
    function center_x_dec(hObject, eventdata) %#ok
    % Callback...        
    	e2_center(1) = e2_center(1) - args.center_steps(1);
        update_ellipse();

    end

% --------------------------------------------------------------------
    function center_y_inc(hObject, eventdata) %#ok
    % Callback...
        %Reverse increment/decrement due to 'y' view
    	e2_center(2) = e2_center(2) - args.center_steps(2);
        update_ellipse();

    end

% --------------------------------------------------------------------
    function center_y_dec(hObject, eventdata) %#ok
    % Callback...        
    	e2_center(2) = e2_center(2) + args.center_steps(2);
        update_ellipse();

    end

% --------------------------------------------------------------------
    function radii_x_inc(hObject, eventdata) %#ok
    % Callback...        
    	e2_radii(1) = e2_radii(1) + args.radii_steps(1);
        update_ellipse();

    end

% --------------------------------------------------------------------
    function radii_x_dec(hObject, eventdata) %#ok
    % Callback...
        if (e2_radii(1) - args.radii_steps(1)) > 0
            e2_radii(1) = e2_radii(1) - args.radii_steps(1);
            update_ellipse();
        end

    end

% --------------------------------------------------------------------
    function radii_y_inc(hObject, eventdata) %#ok
    % Callback...
        
    	e2_radii(2) = e2_radii(2) + args.radii_steps(2);
        update_ellipse();

    end

% --------------------------------------------------------------------
    function radii_y_dec(hObject, eventdata) %#ok
    % Callback...
        if (e2_radii(2) - args.radii_steps(2)) > 0
            e2_radii(2) = e2_radii(2) - args.radii_steps(2);
            update_ellipse();
        end

    end


% --------------------------------------------------------------------
    function rot_inc(hObject, eventdata) %#ok
    % Callback...
        %Rotate
        R = [cos(args.rotation_steps) sin(args.rotation_steps);
            -sin(args.rotation_steps) cos(args.rotation_steps)];
        e2_axes = R*e2_axes;
    	update_ellipse();

    end

% --------------------------------------------------------------------
    function rot_x_dec(hObject, eventdata) %#ok
    % Callback...
        %Rotate 
        R = [cos(args.rotation_steps) -sin(args.rotation_steps);
            sin(args.rotation_steps) cos(args.rotation_steps)];
        e2_axes = R*e2_axes;
    	update_ellipse();

    end
    
% --------------------------------------------------------------------
    function slice_slider(hObject, eventdata) %#ok
    % Callback...
        
    	curr_slice = round(get(ui.slice_slider, 'value'));
        update_view;

    end

% --------------------------------------------------------------------
    function row_slider(hObject, eventdata) %#ok
    % Callback...
        
    	curr_row = round(get(ui.row_slider, 'value'));
        update_view;

    end

% --------------------------------------------------------------------
    function col_slider(hObject, eventdata) %#ok
    % Callback...
        
    	curr_col = round(get(ui.col_slider, 'value'));
        update_view;

    end

% --------------------------------------------------------------------
    function vol_slider(hObject, eventdata) %#ok
    % Callback...
        
    	curr_vol = round(get(ui.vol_slider, 'value'));
        load_volume();

    end

% --------------------------------------------------------------------
    function select_feature(hObject, eventdata) %#ok
    % Callback...
        
        items = get(hObject,'String');
        index_selected = get(hObject,'Value');
        item_selected = items{index_selected};
        display(item_selected);

        switch(item_selected)
            case {'gradient', 'Gradient'} 
                feature_fun = @(x)grad(x, args.grad_sigma);
            case {'none','None'} 
                feature_fun = @none;
            otherwise,     
                error([item_selected 'is not a recognised ''feature_fun'' parameter.'])
        end
        if ~isempty(feature_volume)
            load_volume();
        end
    end

% --------------------------------------------------------------------
    function select_xy_roi(pos)
        a1_x = linspace(1, axes_pos1(3), num_cols);
        a1_y = linspace(1, axes_pos1(4), num_rows);
        a2_x = linspace(1, axes_pos2(3), num_rows);
        a3_x = linspace(1, axes_pos3(3), num_cols);
        
        a2_x_pos = interp1(a1_y, a2_x, pos([2 4]));
        a3_x_pos = interp1(a1_x, a3_x, pos([1 3]));
        
        %temporarily disable callbacks on other rects
        removeNewPositionCallback(ui.rect2, ui.rect2_callback);
        pos = getPosition(ui.rect2);
        pos([1 3]) = a2_x_pos;
        setPosition(ui.rect2, pos);
        ui.rect2_callback = addNewPositionCallback(ui.rect2, @(p) select_yz_roi(p));
        
        removeNewPositionCallback(ui.rect3, ui.rect3_callback);
        pos = getPosition(ui.rect3);
        pos([1 3]) = a3_x_pos;
        setPosition(ui.rect3, pos);
        ui.rect3_callback = addNewPositionCallback(ui.rect3, @(p) select_xz_roi(p));
    end

% --------------------------------------------------------------------
    function select_yz_roi(pos)
        a2_x = linspace(1, axes_pos2(3), num_rows);
        a2_y = linspace(1, axes_pos2(4), num_slices);
        a1_y = linspace(1, axes_pos1(4), num_rows);
        a3_y = linspace(1, axes_pos3(4), num_slices);
        
        a1_y_pos = interp1(a2_x, a1_y, pos([1 3]));
        a3_y_pos = interp1(a2_y, a3_y, pos([2 4]));
        
        %temporarily disable callbacks on other rects
        removeNewPositionCallback(ui.rect1, ui.rect1_callback);
        pos = getPosition(ui.rect1);
        pos([2 4]) = a1_y_pos;
        setPosition(ui.rect1, pos);
        ui.rect1_callback = addNewPositionCallback(ui.rect1, @(p) select_xy_roi(p));
        
        removeNewPositionCallback(ui.rect3, ui.rect3_callback);
        pos = getPosition(ui.rect3);
        pos([2 4]) = a3_y_pos;
        setPosition(ui.rect3, pos);
        ui.rect3_callback = addNewPositionCallback(ui.rect3, @(p) select_xz_roi(p));
    end

% --------------------------------------------------------------------
    function select_xz_roi(pos)
        a3_x = linspace(1, axes_pos3(3), num_cols);
        a3_y = linspace(1, axes_pos3(4), num_slices);
        a1_x = linspace(1, axes_pos1(3), num_cols);
        a2_y = linspace(1, axes_pos2(4), num_slices);
        
        a1_x_pos = interp1(a3_x, a1_x, pos([1 3]));
        a2_y_pos = interp1(a3_y, a2_y, pos([2 4]));
        
        %temporarily disable callbacks on other rects
        removeNewPositionCallback(ui.rect1, ui.rect1_callback);
        pos = getPosition(ui.rect1);
        pos([1 3]) = a1_x_pos;
        setPosition(ui.rect1, pos);
        ui.rect1_callback = addNewPositionCallback(ui.rect1, @(p) select_xy_roi(p));
        
        removeNewPositionCallback(ui.rect2, ui.rect2_callback);
        pos = getPosition(ui.rect2);
        pos([2 4]) = a2_y_pos;
        setPosition(ui.rect2, pos);
        ui.rect2_callback = addNewPositionCallback(ui.rect2, @(p) select_yz_roi(p));
    end
    
%---------------------------------------------------------------------
    function scroll_Callback(hObject, eventdata) %#ok
    % Callback...
        if num_slices
            curr_slice = min(max(curr_slice + eventdata.VerticalScrollCount,1),num_slices);
            set(ui.slice_slider, 'value', curr_slice);
            update_view;
        end
    end


%---------------------------------------------------------------------
    function keypress_Callback(hObject, eventdata) %#ok
    % Callback... 
        
        switch eventdata.Key
            case 'rightarrow'
                center_x_inc();

            case 'leftarrow'
                center_x_dec();

            case 'uparrow'
                center_y_inc();

            case 'downarrow'
                center_y_dec();
                
            case 'l'
                radii_x_inc();
                
            case 'j'
                radii_x_dec();
                
            case 'i'
                radii_y_inc();
                
            case 'k'
                radii_y_dec();            
                
            case 'space'
                if num_vols
                    curr_vol = min(max(curr_vol + 1,1),num_vols);
                    set(ui.vol_slider, 'value', curr_vol);
                    load_volume();
                end
                
            case 'b'
                if num_vols
                    curr_vol = min(max(curr_vol - 1,1),num_vols);
                    set(ui.vol_slider, 'value', curr_vol);
                    load_volume();
                end
                
            case 'q'
                if num_cols
                    curr_col = min(max(curr_col - 1,1),num_cols);
                    set(ui.col_slider, 'value', curr_col);
                    update_view();
                end
                
            case 'w'
                if num_cols
                    curr_col = min(max(curr_col + 1,1),num_cols);
                    set(ui.col_slider, 'value', curr_col);
                    update_view();
                end
                
            case 'a'
                if num_rows
                    curr_row = min(max(curr_row - 1,1),num_rows);
                    set(ui.row_slider, 'value', curr_row);
                    update_view();
                end
                
            case 's'
                if num_rows
                    curr_row = min(max(curr_row + 1,1),num_rows);
                    set(ui.row_slider, 'value', curr_row);
                    update_view();
                end
                
            case 'return'
                update_roi();
                
            case 'backspace'
                reset_roi();
        end 

    end
end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Function to compute feature image
%
%--------------------------------------------------------------------------
function x = none(x)
end

function [feature_vol] = grad(orig_vol, sigma)
    G = cell(1, 3);
    g = ac_gaussian_kernel(ceil(2*sigma*[1 1 1]), sigma*eye(3));
    [G{:}] = gradient(convn(orig_vol, g, 'same'));
    feature_vol = sqrt(G{1}.^2 + G{2}.^2 + G{3}.^2);
end