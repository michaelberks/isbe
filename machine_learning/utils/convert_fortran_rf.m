function [rf_mat] = convert_fortran_rf(rf_fortran, forest_type, forest_path_out, tree_dir)
%CONVERT_FORTRAN_RF converts random forests generated by the Matlab wrapper
%to the Fortran RF package into the Matlab format used at UoM. The new
%format use *much* less memory (i.e. typically 10% or less of the original)
%   [rf_mat] = convert_fortran_rf(rf, forest_path, tree_dir)
%
% Inputs:
%      rf_fortran - Either the fortran random forest itself (will be a
%      struct) or a string path to where the forest is saved
%
%      forest_path_out - Default [], if not empty, path to where the new
%      matlab forets will be saved
%
%      tree_dir - Default [], if empty, the matlab forest is created with
%      all the trees stored as in the forest (so when the forest is loaded
%      all the trees are also loaded into memory). This is suitable for
%      small forests to save reading in each tree from disk during
%      prediction. If not empty, should specify a directory to where each
%      tree is saved (typically a sub-dir of where the forest is saved),
%      the forest then stores a path to each tree, this is suitable for large
%      forests where we don't all the trees loaded into memory at once.
%
%
% Outputs:
%      rf_mat - Random forets in matlab form
%
%
% Example:
%
% Notes: This function has been written because the matlab wrapper for the
% Fortran RF package produces forests that take up an obscene amount of
% memory. This is for 2 reasons: 1) All the trees are stored in a single array
% 2) As a consequence, the fortran code Mallocs arrays of size N*n where N
% is the number of training samples and n is the number of trees. This
% guarantees the data for each tree field will fit in a single row, but
% generates a huge amount of waste - typically about 96-98% of the arrays
% are empty (i.e. just zero padded). This code extracts the useful data
% from each tree into a more sensible data structure to make *much* smaller
% forest. Moreover because the data for each tree is separated the code can
% run with the option (by specifying tree_dir input) to save each tree
% separately, thus allowing them to be loaded separately during predictions.
% Note also that despite the obscene amount of memory allocated to the
% Fortran forests, each tree actually stores *less* useful information than
% the Matlab forest, as the actuall class counts at each tree node are not
% saved, nor are the final proportions at each leaf (only the majority
% class is saved). As a result, tree fields such as the classprobs,
% nodeprobs, noderrs and noderisk can't be recovered. Instead we 'fake'
% these by assuming each leaf node contains just one sample, which by
% definition is a sample of the class assigned to that leaf. We then
% back-propogate these samples back through the tree to give a class count
% at each node. Of course this means that caution should be taken in using
% the matlab forests produced by this script for anything other than majority
% class voting. In particular that means *use_probs* should be turned off
% (i.e. set to 0) in random_forest_class_predict. 
% It is also worth noting that predicting using the new forest and random_forest_class_predict 
% is likely to be much slower than using the old fortran forest with classRF_predict.
% However this tradeoff is probably worth it (and at times necessary) if you
% can't actually load the original forest into memory (as is the case with
% models trained on reasonable amount data using a standard PC).
%
% See also: RANDOM_FOREST_CLASS_PREDICT CLASSRF_TRAIN CLASSRF_PREDICT
%
% Created: 26-Oct-2015
% Author: Michael Berks 
% Email : michael.berks@manchester.ac.uk 
% Phone : +44 (0)161 275 7669 
% Copyright: (C) University of Manchester 

%Set default arguments
if ~exist('forest_type', 'var') || isempty(forest_type)
    forest_type = 'classification';
end
if ~exist('forest_path_out', 'var')
    forest_path_out = [];
end
if ~exist('tree_dir', 'var')
    tree_dir = [];
end

%Create tree folder (make sure it is filesep terminated)
if ~isempty(tree_dir)
    if (tree_dir(end) ~= '/' || tree_dir(end)~='\')
        tree_dir = [tree_dir '/'];
    end
end
create_folder(tree_dir);

%Load in the FORTRAN forest, warning this may be BIGGGGG! (Hence the need
%for this method)
if ~isstruct(rf_fortran) && ischar(rf_fortran)
    rf_fortran = u_load(rf_fortran);
end

%Set up general properties of forest
num_trees = rf_fortran.ntree;
num_classes = length(rf_fortran.new_labels);
rf_mat.tree_dir = tree_dir;
rf_mat.tree_root = [];
rf_mat.D = size(rf_fortran.importance,1);
rf_mat.d = rf_fortran.mtry;
rf_mat.nclasses = num_classes;
rf_mat.classname = rf_fortran.new_labels;
rf_mat.prior = [];
rf_mat.cost = [];
rf_mat.names = [];
rf_mat.trees = cell(num_trees,1);

%Now get details of each individual tree
for i_tree = 1:num_trees;
    
    tree.alpha = [];
    tree.prunelist = [];
    tree.catcols = [];
    tree.npred = rf_mat.D;
    
    tree.method = forest_type;
    
    if strcmpi(forest_type, 'classification')
        
        %Compute num nodes
        num_nodes = sum(rf_fortran.nodestatus(:,i_tree) ~=0);
        
        %Get node information:
        
        %Get node children from tree map
        tree.children = uint32(reshape(rf_fortran.treemap(1:2*num_nodes,2*i_tree - 1), 2, num_nodes)');
        
        %Workout node parents from children (noting that this therefore is
        %redundant data)
        tree.parent = zeros(num_nodes,1, 'uint32');
        for i_n = 1:num_nodes
            if tree.children(i_n,1)
                tree.parent(tree.children(i_n,1)) = i_n;
                tree.parent(tree.children(i_n,2)) = i_n;
            end
        end
        
        %Get variable and split threshold used at each split node
        tree.var = uint16(rf_fortran.bestvar(1:num_nodes,i_tree));
        tree.cut = rf_fortran.xbestsplit(1:num_nodes,i_tree);
        
        %Set the node labels to be 1,...,num_nodes
        tree.node = unint32((1:num_nodes)');
        
        %Copy over the tree class and class labels
        old_class_names = rf_fortran.new_labels;
        tree.classname = 0:num_classes-1;
        old_classes = rf_fortran.nodeclass(1:num_nodes,i_tree);
    
        tree.class = zeros(num_nodes,1, 'uint8'); 
        for i_class = 1:num_classes
            class_idx = old_classes == old_class_names(i_class);
            tree.class(class_idx) = tree.classname(i_class);
        end
        
        %If we have class counts at ecah node we can compute everything
        %else... But the dumb fortran wrapper doesn't give us the class
        %counts!
        %While we try and work out something better to do, let's assume
        %every leaf is has just one sample of it's leaf class. We can than
        %work our way back up the tree from there...
        tree.classcount = zeros(num_nodes,1, 'uint32');
        for i_class = 1:num_classes
            idx = tree.class == tree.classname(i_class);
            tree.classcount(idx,i_class) = 1;
        end
        
        leaves = tree.node(tree.class > 0);
        for i_l = 1:length(leaves)
            curr_node = leaves(i_l);
            leaf_count = tree.classcount(curr_node,:);
            while curr_node ~= 1
                parent = tree.parent(curr_node);
                tree.classcount(parent,:) = tree.classcount(parent,:) + leaf_count;
                curr_node = parent;
            end
        end
        
        class_counts = double(tree.classcount(1,:));
        tree.nodeprob = double(tree.classcount(:,1)) / class_counts(1);
        for i_class = 2:num_classes
            tree.nodeprob = tree.nodeprob ...
                + tree.classcount(:,i_class) / class_counts(i_class);
        end
        tree.nodeprob = tree.nodeprob / num_classes;
        tree.nodesize = sum(tree.classcount,2);
        
        class_priors = class_counts / sum(class_counts);
        p_x_c = bsxfun(@rdivide, double(tree.classcount), double(tree.nodesize));
        p_x_c_p_c = bsxfun(@rdivide, p_x_c, class_priors);
        tree.classprob = bsxfun(@rdivide, p_x_c_p_c, sum(p_x_c_p_c,2));
        tree.nodeerr = min(tree.classprob,[],2);
        tree.risk = tree.nodeerr.*tree.nodeprob;
        
        if isempty(tree_dir)
            rf_mat.trees{i_tree} = tree;
        else
            rf_mat.trees{i_tree} = ['rf_tree' zerostr(i_tree,4) '.mat'];
            save([tree_dir rf_mat.trees{i_tree}], 'tree');
        end
            
    elseif strcmpi(forest_type, 'regression')
        
    else
        error(['Forest type ' forest_type ' not recognised.']);
    end
end

if ~isempty(forest_path_out)
    save(forest_path_out, 'rf_mat');
end
     
     